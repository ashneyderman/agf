# Task management

Create a task manager that can read tasks from the variety of sources such as .md files or JIRA.

The task manager will serve as a conduit between task source and the system that consumes the tasks and executes them. Task manager manages task's deuplication and updates to the task's state.

# Data Model

Create pydantic base data model for worktrees and tasks. We expect task instance to be created from JSON data like this:

```json
[
  {
    "worktree_name": "worktree_name",
    "tasks_to_start": [
      {
        "description": "task description",
        "tags": ["tag1", "tag2"]
      }
    ]
  }
]
```

Tasks will have additional attributes not found in JSON parsed such as task_id (value generated by generate_short_id of length 6), status (not_started, in_progress, completed, blocked, failed), sequence_number - task sequence within a worktree, and commit sha.

Worktrees will have additional attributes that will indicate the directory path to the worktree and head sha. Worktrees are containers of tasks.

TaskSource will be a protocol that will be able to list tasks, update task instance status in their source, indicate if task has an error. For starters the only implementation of task source will be .md file. When task manager initializes it will have to receive TaskSource instance to be able to initialize and maintain its state.

# TaskManager Implementation

Create a task manager that will be a single global instance that will manage tasks.

- impements a method to add tasks. This method will take raw worktrees (no sha's or ids assigned yet) and upsert them into the state of the task manager.
  - worktree deduplication works by comparing worktree names.
  - task deduplication works by comparing task descriptions.

- implements a method to udpate task status
- implements a method to update task id at the source
- implements a method to mark task in error
- implements a method to fetch next available tasks: task is available if its status is pending. Method receives an argument that indicates how many next tasks to fetch.

# TaskSource implementation

The first implementation of TaskSource will be a MarkdownTaskSource. Which will read .md file for the source of tasks. This task source will receive the location of the .md file as an argument at initialization.

Each worktree starts with `##` <name> {<agf_id>}. The list of tasks is a unordered list. Each task has the following format: <task_state> <description> {tag1, tag2, ...}. <task_state> is a field that is wrapped in `[]` and contains comma separated values for <status>, <task_id>, <git sha>. <description> is a field that contains the task description, that could be multi-line description. The last section wrapped within `{}` is a list of optional tags.

## Task Status Guide

- `[]` - Not started (ready for pickup)
- `[‚è∞]` - Not started and blocked (can only start when all tasks above in the worktree are successful)
- `[üü°]` - Work in progress (skip these)
- `[‚úÖ]` - Success (completed)
- `[‚ùå]` - Failed (terminal state)

## Examples

### Example 1: Task in progress blocks dependent task

Given this task list:

```

## Git Worktree feature-auth

[‚úÖ, ntjnwftq, 17d16d17] Task 1
[üü°, qbrlerfg] Task 2
[] Task 3 {api, auth}
[‚è∞] Task 4

```

Task 1 is completed with task_id `ntjnwftq` and git sha `17d16d17`. Task 2 is in progress with task_id `qbrlerfg`. Task 3 is ready to be picked up. Task 4 is blocked because Task 2 is still in progress.

### Example 2: Failed task prevents blocked task from running

Given this task list:

```

## Git Worktree create-topic-filter

[‚ùå, 17d16d17] Generate filtered dataset at data/tweets_tech_topics.csv containing only technology and entertainment topics from tweets_v1.csv
[‚è∞] Add 30 new tweets about sports and recreation to expand topic diversity in tweets_v1.csv

```

The blocked task (Add 30 new tweets) will NOT be eligible for pickup because the task above it failed.
Blocked tasks require ALL preceding tasks in the same worktree to be successful (`[‚úÖ]`) before they can run.
No tasks would be returned as eligible from this worktree.

## Notes:

### Task ID Generation

```python
import secrets

def generate_short_id(length):
    """Generate a cryptographically secure random string of a given length."""
    alphabet = "ABCDEFGHJKLMNPQRSTUWXYZ"
    return "".join(secrets.choice(alphabet) for _ in range(length))
```
